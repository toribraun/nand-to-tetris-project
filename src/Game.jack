class Game {
    field Car car;
    field int opponentCarsCount;
    field Array opponentCars;
    field int tracksCount;
    field int blockSize;
    field int carWidth, carHeight;
    field int gap;
    field int delayTime;
    field int delayTimeStep;
    field int score;

    constructor Game new() {
        let carWidth = 2;
        let carHeight = 3;
        let blockSize = 256 / 16;
        let gap = 4;
        let car = Car.new(carWidth, carHeight, blockSize, gap);
        let opponentCarsCount = 1;
        let opponentCars = Array.new(opponentCarsCount);
        do FillOpponentCars();
        let tracksCount = 2;
        let delayTime = 150;
        let delayTimeStep = 25;
        let score = 0;
        return this;
    }

    method void FillOpponentCars() {
        var int i;
        let i = 0;
        while (i < opponentCarsCount) {
            let opponentCars[i] = OpponentCar.new(carWidth, carHeight, blockSize, gap);
            let i = i + 1;
        }
        return;
    }

    method void run() {
        var boolean exit;
        var int key;

        let exit = false;
        do car.Draw();
        do MoveOpponentCars();
        while(~exit) {
            do Screen.clearScreen();
            do DrawBorders();
            do PrintScore();
            let key = Keyboard.keyPressed();
            if( key = 81 ) {
                // q
                let exit = true;
            }
            if( key = 130 ) {
                // left arrow
                do car.ChangeTrackLeft();
            }
            if( key = 132 ) {
                // right arrow
                do car.ChangeTrackRight(tracksCount);
            }
            if( key = 131 ) {
                // up arrow
                do SpeedUp();
            }
            if( key = 133 ) {
                // down arrow
                do SpeedDown();
            }

            if( CheckCollision() ) {
                do DrawGameOver();
                do Sys.halt();
                return;
            } 

            do car.Draw();
            do MoveOpponentCars();

            do Sys.wait(delayTime);
        }

        do DrawExit();
        do Sys.halt();

        return;
    }

    method void MoveOpponentCars() {
        var int i;
        var OpponentCar currentCar;
        let i = 0;
        while (i < opponentCarsCount) {
            let currentCar = opponentCars[i];
            if (~currentCar.TryMove()) {
                do ScoreUp();
                do currentCar.dispose();
                let opponentCars[i] = OpponentCar.new(carWidth, carHeight, blockSize, gap);
            }
            do currentCar.Draw();
            let i = i + 1;
        }

        return;
    }

    method void DrawBorders() {
        var int leftBorderX, rightBorderX;
        do Screen.setColor(true);

        let leftBorderX = 512 / 2 - (carWidth * blockSize * (tracksCount / 2)) - gap;
        do Screen.drawLine(leftBorderX, 0, leftBorderX, 255);

        let rightBorderX = 512 / 2 + (carWidth * blockSize * (tracksCount / 2));
        do Screen.drawLine(rightBorderX, 0, rightBorderX, 255);
        return;
    }

    method boolean CheckCollision() {
        var int i;
        let i = 0;
        while (i < opponentCarsCount) {
            if (car.CheckCollision(opponentCars[i])) {
                return true;
            }
            let i = i + 1;
        }
        return false;
    }

    method void ScoreUp() {
        let score = score + 1;        
        return;
    }

    method void PrintScore() {
        do Output.moveCursor(0, 0);
        do Output.printString("Score: ");
        do Output.printInt(score);
        return;
    }

    method void SpeedUp() {
        if ((delayTime - delayTimeStep) > 25) {
            let delayTime = delayTime - delayTimeStep;
        }
        return;
    }

    method void SpeedDown() {
        if ((delayTime + delayTimeStep) < 275) {
            let delayTime = delayTime + delayTimeStep;
        }
        return;
    }

    method void DrawGameOver() {
        return;
    }

    method void DrawExit() {
        return;
    }

    method void dispose() {
		do Memory.deAlloc(this);
		return;
	}
}
